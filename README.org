* slummer

  *A Sordid Tale in which Lisp Visits the Browser*

  Slummer is (for now) a tool to create web front ends and static sites in
  Common Lisp. It is both a library and a command line tool.

*** Key features  

    - *100% Lisp*. Never write a single line of HTML, JavaScript, or CSS.
    - *Development Server*. Fire up the server and watch your app rebuild whenever
      your app's source changes.
    - Supports *reactive components* (if you want them) using the ~defstate~ and
      ~defview~ macros. 
    - Uses [[https://shinmera.github.io/LASS/][LASS]] and [[https://github.com/ruricolist/spinneret][Spinneret]] for CSS and HTML generation respectively.
    - Uses [[https://common-lisp.net/project/parenscript/][Parenscript]] (for the time being, see below) to generate Javascript.
    - Also includes a number of Parenscript macros to support *modules*,
      *structs*, and a psuedo *defmethod* in your Parenscript code.

** Check It Out

    To start a new project with slummer, open up your favorite terminal emulator
    and do:

#+begin_example
~$ slummer new some-kludge
~$ cd some-kludge
~$ slummer run

Visit http://127.0.0.1:5000/ in your browser. 
Press Ctl-C to exit the test serer environment.         
Building project ...                                    

#+end_example


  Now you can open your browser, point it to ~http://127.0.0.1:5000~, and see this:
  [[./.readme/hello-click-fiend.gif]]
  
  The default application is a simple button clicker, and it includes a few files:

  - ~main.lisp~ a lisp file containing a page definition and the entry point for
    the build process
  - ~app.paren~ a parenscript file defining application behaviors and state
  - ~style.lass~ a file containing s-expression that are interpreted as [[https://shinmera.github.io/LASS/][lass]],
    used to generate css at build time.

  The ~slummer run~ command builds the project and runs the development server,
  which will recompile your project whenever you make a change to any of your
  project files. Specifically, changes to files that end in ~.lisp~, ~.paren~,
  or ~.lass~ will trigger a project rebuild.

*** The Main Lisp File 

  Every slummer project needs to call the ~build-site~ function at some point to
  actually build the site. The default project generated by ~slummer new~
  includes a ~main.lisp~ that looks like this:

#+begin_src lisp

(defpackage #:some-kludge
  (:use #:cl #:slummer))

(in-package #:some-kludge)

(defparameter +made-with-version+ '(0 4 0))

;; variable holding the site
(defvar *some-kludge-site*)
(setf *some-kludge-site* (fresh-site))

;; A site context section.
;; You can add more if you want to define pages
;; in different contexts.
(with-site-context (*some-kludge-site*) ; add context keywords if you need them

  (include "app.paren")
  (include "style.lass")

  (defpage "index.html" (:scripts ("app.js") :styles ("style.css"))
    (:h1 "Hello, Click Fiend.")
    (:div :id "clicker-1")
    (:div :id "clicker-2" ))
  )

(build-site *some-kludge-site*)

#+end_src

 In the above, you see a variable called ~*some-kludge-site*~ set to the value
 of ~(fresh-site)~, which returns a *site context*. A site context is a data
 structure that holds and organizes the objects that will be built (i.e. that
 will end up as static HTML, JavaScript, and CSS files). In particular, the site
 context holds _page defintions_, _style defintions_, _media file locations_,
 _scripts_, and so on. A site context is passed to the ~build-site~ function,
 which, well, builds the site.

 Once a site context is available, the ~with-site-context~ macro is used to
 create or include objects into the site context. In this case, two files are
 "included" into the project, and an HTML page defined "inline".

*** The Example Parenscript File 

    The bulk of the code of a ~slummer~ front end application is likely to
    appear within a number of Parenscript files. The above ~slummer new~ command
    generated an ~app.paren~ that looks like this:

#+begin_src lisp
(defmodule *some-kludge*

  ;;; IMPORTS
  (import-from (*slummer* *html*) p div button)
  (import-from *slummer* on)

  ;;; MODULE CODE

  (defun make-counter-state ()
    ({} count 0))

  (defstate first-counter (make-counter-state))
  (defstate second-counter (make-counter-state))

  (defview main-view (state)
    ((inc-clicks () (incf (@> state count))))
    (div ()
         (p () (@> state count))
         (button ({} :onclick inc-clicks) "click me")))

  (on window "load"
      (lambda ()
        (main-view "clicker-1" first-counter)
        (main-view "clicker-2" second-counter))))
#+end_src
 
  Quickly take note of the following features:
  
  - You can define parenscript modules
  - You can import functions from other parenscript modules (and you can export
    too, but that isn't demonstrated in the above)
  - A ~defstate~ is used to define "reactive" states.
  - And ~defview~ is used to devine UI components that change in response to
    states. The result of a ~defview~ form is a function that is called with a
    real DOM object (or, as above, its id attribute) and one ore more reactive
    states. When any state is updated, so is the view. In the above, we only
    pass one state to each of our view invocations.
  - Finally, we load our views when the window ~load~ event fires.


** TO DO
   
   Pracctically everything. I am writing ~slummer~ because I want to enjoy
   writing web frontends again. There are a number of features and modes of
   thought that I would like to support in ~slummer~ that are presently missing.
   
   It is quite possible that Parenscript will need to be replaced or updated in
   the project.

   My most salient aims include the following:

   1. [ ] Forms for defining and using common kinds of layouts - rather like the
      ~defpage~ macro you see above. Preferably the layouts could compose and
      nest.
   2. [ ] Better JS situation
      - [ ] Generate modern JS code (i.e. ES6's lexical bindings, destructuring,
        etc) for more readable output. (One of the goals is to generate output
        that some non-lisper wouldn't mind reading).
      - [ ] Support JS modules natively, instead of the immediate function
        approach that ~slummer~ presently uses.
      - [ ] async/await support (would require augmenting / replacing Parenscript)
      - [ ] generators and yeild
      - [ ] utilize for-of and for-in loops in generated output.
   3. [ ] Basic support for conditions and restarts in the Javascript
      environment. ([[https://www.reddit.com/r/LispMemes/comments/chw574/algebraic_effects/]["algebraic effects"]] anyone? LOL)
   4. [ ] In-Browser REPL (would probably be a Parenscript application that
      knows parenscript - one problem would be access to the ~defpsmacro~ forms
      defined in ~slummer~.)
   5. [ ] User-defined project templates to pass to ~slummer new~.

