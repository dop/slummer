* slummer

  *A Sordid Tale in which Lisp Visits the Browser*

  Slummer is (for now) a tool to create web front ends and static sites in
  Common Lisp. It is both a library and a command line tool.

*** Key features  

    - *100% Lisp*. Never write a single line of HTML, JavaScript, or CSS.
    - *Development Server*. Fire up the server and watch your app rebuild whenever
      your app's source changes.
    - Supports *reactive components* (if you want them) using the ~defstate~ and
      ~defview~ macros. 
    - Uses [[https://shinmera.github.io/LASS/][LASS]] and [[https://github.com/ruricolist/spinneret][Spinneret]] for CSS and HTML generation respectively.
    - Uses [[https://common-lisp.net/project/parenscript/][Parenscript]] (for the time being, see below) to generate Javascript.
    - Also includes a number of Parenscript macros to support *modules*,
      *structs*, and a psuedo *defmethod* in your Parenscript code.

** Check It Out

    To start a new project with slummer, open up your favorite terminal emulator
    and do:

#+begin_example
~$ slummer new some-kludge
~$ cd some-kludge
~$ slummer run

Visit http://127.0.0.1:5000/ in your browser. 
Press Ctl-C to exit the test serer environment.         
Building project ...                                    

#+end_example


  Now you can open your browser, point it to ~http://127.0.0.1:5000~, and see this:
  [[./.readme/hello-click-fiend.gif]]
  
  The default application is just a simple clicker. When a new project was
  generated, a few files were created:

  - ~main.lisp~ a lisp file containing a page definition and the entry point for
    the build process
  - ~app.paren~ a parenscript file defining application behaviors and state
  - ~style.lass~ a file containing s-expression tha are interpreted as [[https://shinmera.github.io/LASS/][lass]],
    used to generate css at build time.

  The ~slummer run~ command builds the project and runs the development server,
  which will recompile your project whenever you make a change to any of your
  project files. Specifically, changes to files that end in ~.lisp~, ~.paren~,
  or ~.lass~ will trigger a project rebuild.

*** The Main Lisp File 

  Every slummer project needs to call the ~build-site~ function at some point to
  actually build the site. The default project generated by ~slummer new~
  includes a ~main.lisp~ looks like this:

#+begin_src lisp

(defpackage #:some-kludge
  (:use #:cl #:slummer))

(in-package #:some-kludge)

(defparameter +made-with-version+ '(0 4 0))

;; variable holding the site
(defvar *some-kludge-site*)
(setf *some-kludge-site* (fresh-site))

;; A site context section.
;; You can add more if you want to define pages
;; in different contexts.
(with-site-context (*some-kludge-site*) ; add context keywords if you need them

  (include "app.paren")
  (include "style.lass")

  (defpage "index.html" (:scripts ("app.js") :styles ("style.css"))
    (:h1 "Hello, Click Fiend.")
    (:div :id "clicker-1")
    (:div :id "clicker-2" ))
  )

(build-site *some-kludge-site*)

#+end_src

 In the above, you see a variable called ~*some-kludge-site*~ set to the value
 of ~(fresh-site)~, which returns a *site context*. A site context is a data
 structure that used to hold and organize all of the objects that will
 eventually be built. In particular, the site context holds page defintions,
 style defintions, media file locations, scripts, and so on. A site context is
 then passed to ~build-site~ as the last step.

 Once a site context is available, the ~with-site-context~ is used to create
 some build objects. In this case, two files are "included" into the project,
 and an HTML page defined "inline".

*** The Example Parenscript File 

    The bulk of the code of a ~slummer~ front end is likely to be within
    Parenscript files. The ~slummer new~ command generated an ~app.paren~ that
    looks like this:

#+begin_src lisp
(defmodule *some-kludge*

  ;;; IMPORTS
  (import-from (*slummer* *html*) p div button)
  (import-from *slummer* attach-view on)
  (import-from (*slummer* *util*) list)

  ;;; MODULE CODE

  (defun make-counter-state ()
    ({} count 0))

  (defstate first-counter (make-counter-state))
  (defstate second-counter (make-counter-state))

  (defview main-view (state)
    ((inc-clicks () (incf (@> state count))))
    (div ()
         (p () (@> state count))
         (button ({} :onclick inc-clicks) "click me")))

  (on window "load"
      (lambda ()
        (main-view "clicker-1" first-counter)
        (main-view "clicker-2" second-counter))))
#+end_src
 
  Quickly take note of the following features:
  
  - You can define parenscript modules
  - You can import functions from other parenscript modules (and you can export
    too, but that isn't demonstrated in the above)
  - A ~defstate~ is used to define "reactive" states.
  - And ~defview~ is used to devine UI components that change in response to
    states. The result of a ~defview~ form is a function that is called with a
    real DOM object (or, as above, its id attribute) and one ore more reactive
    states. When any state is updated, so is the view. In the above, we only
    pass one state to each of our view invocations.
  - Finally, we load our views when on the window ~load~ event.


** TO DO
   
   Pracctically everything. I am writing ~slummer~ because I want to enjoy
   writing web frontends again. There are a number of features and modes of
   thought that I would like to support in ~slummer~ that are presently missing.
   
   It is quite possible that Parenscript will need to be replaced or updated in
   the project.

   My most salient aims include the following:

   1. [ ] Forms for defining and using common kinds of layouts - rather like the
      ~defpage~ macro you see above. Preferably the layouts could compose and
      nest.
   2. [ ] Better JS situation
      - [ ] Generate modern JS code (at least ES6)
      - [ ] Support JS modules natively, instead of the immediate function
        approach that ~slummer~ presently uses.
      - [ ] async/await support (would require augmenting / replacing Parenscript)
   3. [ ] Basic support for conditions and restarts in the Javascript
      environment. (algebraic effects anyone?)
   4. [ ] In-Browser REPL (would probably be a Parenscript application that
      knows parenscript - one problem would be access to the ~defpsmacro~ forms
      defined in ~slummer~.)
   5. [ ] User-defined project templates to pass to ~slummer new~.

